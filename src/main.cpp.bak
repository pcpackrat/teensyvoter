/*
  TeensyVoter - Voter Receiver/Transmitter Firmware
  Platform: Teensy 4.1 + Audio Shield
  Network: ESP32 (SPI) or Native Ethernet

  Dependencies:
  - FNET (NativeEthernet)
  - Audio, SPI, Wire
  - TinyGPSPlus
*/

#include "ConfigManager.h"
#include "DSPProcessor.h"
#include "EspSpiDriver.h"
#include "GPSManager.h"
#include "NetworkManager.h"
#include "VoterClient.h"
#include "VoterProtocol.h"
#include "WebInterface.h"
#include <Arduino.h>
#include <Audio.h>
#include <NativeEthernet.h>
#include <SPI.h>
#include <Wire.h>

// --- Global State ---
float g_headphoneVol = 0.5f;
bool g_testToneMode = false;
float g_testTonePhase = 0.0f;
volatile float g_avgSum = 0.0f;
volatile int g_avgCount = 0;
// Buffer for 8kHz downsampled audio
int16_t accumulationBuf[512]; // Circular-ish buffer for outgoing samples
int accHead = 0;
float samplePosition = 0.0f; // For fractional downsampling

// --- Configuration (Managed by ConfigManager) ---
// const char* CLIENT_PWD = "password"; (Removed)
// const char* HOST_PWD   = "bloodhound";
// IPAddress   HOST_IP(192, 168, 1, 100);
// uint16_t    HOST_PORT = 1667;

// --- Audio System ---
AudioInputI2S i2s_in;
AudioMixer4 mixer1;
AudioRecordQueue recordQueue;
AudioConnection patchCord1(i2s_in, 0, mixer1, 0);
AudioConnection patchCord2(i2s_in, 1, mixer1, 1);
AudioConnection patchCord3(mixer1, 0, recordQueue, 0);
AudioOutputI2S i2s_out;
// Bypass Mixer for diagnostics: Left In -> Left Headphone
AudioConnection patchCord4(i2s_in, 0, i2s_out, 0);
// AudioConnection patchCord5(i2s_in, 1, i2s_out, 1);
AudioSynthWaveformSine sine1;
AudioConnection patchCord5(sine1, 0, i2s_out,
                           1); // Right Headphone = Generated Tone
AudioControlSGTL5000 sgtl5000_1;

// --- Global Objects ---
// Select your Active Driver Here:
// EthernetDriver ethDriver;
EspSpiDriver spiDriver(26, 24, 25); // CS=26 (Uncovered), Ready=24, Reset=25
NetworkManager netMgr;
GPSManager gpsMgr;
VoterClient voter;
DSPProcessor dsp;
WebInterface web;
ConfigManager cfg;

byte mac[] = {0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED};

uint8_t g_simRSSI = 0; // 0 = Disabled, 1-255 = Forced Value
bool g_noSignalMode =
    false; // If true, suppress all audio sending (simulated squelch)

// -----------------------------------------------------------------------------
// Helper: Reset Audio State
// -----------------------------------------------------------------------------
void resetAudioState() {
  // Clear DSP filters
  // dsp.reset(); // If DSP class has reset

  // Reset decimation
  g_avgSum = 0.0f;
  g_avgCount = 0;
  accHead = 0;
  samplePosition = 0.0f;
  g_testTonePhase = 0.0f;

  memset(accumulationBuf, 0, sizeof(accumulationBuf));
  recordQueue.clear();
  Serial.println("Audio State Reset");
}

// Helper for proper input echo
String readStringEcho() {
  String buffer = "";
  while (true) {
    if (Serial.available()) {
      char c = Serial.read();
      // Handle Enter
      if (c == '\r' || c == '\n') {
        Serial.println(); // Newline on terminal
        return buffer;
      }
      // Handle Backspace (0x08 or 0x7F)
      if (c == 0x08 || c == 0x7F) {
        if (buffer.length() > 0) {
          buffer.remove(buffer.length() - 1);
          Serial.print("\b \b"); // Erase character visually
        }
      } else {
        // Normal Character
        buffer += c;
        Serial.print(c);
      }
    }
  }
}

void printMenu() {
  IPAddress ip = cfg.getHostIP();
  char ipStr[20];
  sprintf(ipStr, "%u.%u.%u.%u", ip[0], ip[1], ip[2], ip[3]);

  Serial.println("\r\n========================================");
  Serial.println("\r           TEENSY VOTER MENU            ");
  Serial.println("\r========================================");
  Serial.printf(" [1] Host IP     : %-15s\r\n", ipStr);
  Serial.printf(" [2] Host Port   : %-5u\r\n", cfg.data.hostPort);
  Serial.printf(" [3] RSSI Mode   : %s\r\n",
                cfg.data.useHwRSSI ? "HARDWARE (Analog)" : "SOFTWARE (DSP)");
  Serial.printf(" [4] Client PWD  : %s\r\n", cfg.data.clientPwd);
  Serial.printf(" [5] Host PWD    : %s\r\n", cfg.data.hostPwd);
  Serial.printf(" [6] COS Mode    : %s\r\n",
                cfg.data.cosMode == COS_MODE_ALWAYS_ON  ? "Always On"
                : cfg.data.cosMode == COS_MODE_HARDWARE ? "Hardware GPIO"
                                                        : "DSP Squelch");
  Serial.printf(" [7] DSP Squelch : %u\r\n", cfg.data.dspSquelchThresh);
  Serial.printf(" [R] Sim RSSI    : %u\r\n", g_simRSSI);
  Serial.printf(" [N] No Signal   : %s\r\n",
                g_noSignalMode ? "ON (No Audio)" : "OFF");
  Serial.printf(" [G] Set RX Gain  : %u (0-15)\r\n", cfg.data.rxGain);
  Serial.printf(" [H] Headphone Vol: %d (0-100)\r\n",
                (int)(g_headphoneVol * 100));
  Serial.printf(" [L] Input Source: %s\r\n",
                cfg.data.inputSource == AUDIO_INPUT_MIC ? "MIC" : "LINE IN");
  Serial.printf(" [T] Test Tone    : %s\r\n",
                g_testToneMode ? "ON (1kHz sine wave)" : "OFF");
  Serial.println("----------------------------------------");
  Serial.printf(" [8] Cal Min RSSI: %u (Current: %d)\r\n", cfg.data.rssiMin,
                analogRead(RSSI_PIN));
  Serial.printf(" [9] Cal Max RSSI: %u (Current: %d)\r\n", cfg.data.rssiMax,
                analogRead(RSSI_PIN));
  Serial.println("\r----------------------------------------");
  Serial.println("\r [S] Save & Reboot");
  Serial.println("\r [C] Resend WiFi Credentials");
  Serial.println("\r [M] Refresh Menu");
  Serial.println("\r [I] GPS Status");
  Serial.println("\r [D] Signal Monitor (Live Dashboard)");
  Serial.println("========================================\r\n");
  Serial.print("> ");
}

void handleSerialCLI() {
  if (Serial.available()) {
    char c = Serial.read();
    switch (c) {
    case 'c':
    case 'C':
      Serial.println("\nResending WiFi Credentials...");
      spiDriver.setCredentials("ImWatchinYou", "n0Password");
      break;
    case 'm':
    case 'M':
      printMenu();
      break;
    case '1': {
      Serial.print("\nEnter New Host IP: ");
      // Use new non-blocking-ish echo reader
      String ipStr = readStringEcho();
      ipStr.trim();
      IPAddress newIP;
      if (newIP.fromString(ipStr)) {
        cfg.setHostIP(newIP);
        Serial.print("Updated Host IP to: ");
        Serial.println(newIP);
      } else {
        Serial.println("Invalid IP Address!");
      }
      // Reprint menu to show change
      printMenu();
      break;
      break;
    }
    case '2': {
      Serial.print("\nEnter New Host Port: ");
      String portStr = readStringEcho();
      int port = portStr.toInt();
      if (port > 0 && port < 65535) {
        cfg.data.hostPort = (uint16_t)port;
        Serial.printf("\nUpdated Port to: %u\n", cfg.data.hostPort);
      } else {
        Serial.println("\nInvalid Port!");
      }
      printMenu();
      break;
    }
    case '3': {
      cfg.data.useHwRSSI = !cfg.data.useHwRSSI;
      Serial.printf("\nToggled RSSI Mode to: %s\n",
                    cfg.data.useHwRSSI ? "HARDWARE" : "SOFTWARE");
      printMenu();
      break;
    }
    case '4': {
      Serial.print("\nEnter Client Password: ");
      String pwd = readStringEcho();
      pwd.trim();
      if (pwd.length() < 20) {
        strcpy(cfg.data.clientPwd, pwd.c_str());
        Serial.println("\nUpdated Client Password.");
      } else {
        Serial.println("\nPassword too long (Max 19 chars)!");
      }
      printMenu();
      break;
    }
    case '5': {
      Serial.print("\nEnter Host Password: ");
      String pwd = readStringEcho();
      pwd.trim();
      if (pwd.length() < 20) {
        strcpy(cfg.data.hostPwd, pwd.c_str());
        Serial.println("\nUpdated Host Password.");
      } else {
        Serial.println("\nPassword too long (Max 19 chars)!");
      }
      printMenu();
      break;
    }
    case 's':
    case 'S':
      cfg.save();
      Serial.println("\nSaving Config & Rebooting...");
      delay(1000);
      SCB_AIRCR = 0x05FA0004; // System Reset
      break;
    case 'g':
    case 'G': {
      Serial.print("\nEnter RX Gain (0-15, default 5): ");
      String val = readStringEcho();
      int g = val.toInt();
      if (g >= 0 && g <= 15) {
        cfg.data.rxGain = (uint8_t)g;
        sgtl5000_1.lineInLevel(cfg.data.rxGain);
        Serial.printf("\nRX Gain set to %u\n", cfg.data.rxGain);
      } else {
        Serial.println("\nInvalid Value (0-15).");
      }
      printMenu();
      break;
    }
    case 'h':
    case 'H': {
      Serial.print("\nEnter Headphone Vol (0-100): ");
      String val = readStringEcho();
      int v = val.toInt();
      if (v >= 0 && v <= 100) {
        g_headphoneVol = (float)v / 100.0f;
        sgtl5000_1.volume(g_headphoneVol);
        Serial.printf("\nHeadphone Volume set to %d\n", v);
      } else {
        Serial.println("\nInvalid Value (0-100).");
      }
      printMenu();
      break;
    }
    case 'l':
    case 'L': {
      if (cfg.data.inputSource == AUDIO_INPUT_LINEIN) {
        cfg.data.inputSource = AUDIO_INPUT_MIC;
        sgtl5000_1.inputSelect(AUDIO_INPUT_MIC);
        sgtl5000_1.micGain(40); // Default robust mic gain
        Serial.println("\nInput switched to MIC (Gain 40dB)");
      } else {
        cfg.data.inputSource = AUDIO_INPUT_LINEIN;
        sgtl5000_1.inputSelect(AUDIO_INPUT_LINEIN);
        sgtl5000_1.lineInLevel(cfg.data.rxGain);
        Serial.println("\nInput switched to LINE IN");
      }
      printMenu();
      break;
    }
    case 'i':
    case 'I':
      Serial.println("\r\n--- GPS Status ---");
      Serial.printf("Locked    : %s\r\n", gpsMgr.isLocked() ? "YES" : "NO");
      Serial.printf("Time Set  : %s\r\n", gpsMgr.isTimeSet() ? "YES" : "NO");
      if (gpsMgr.isTimeSet()) {
        VTIME t;
        gpsMgr.getNetworkTime(&t);
        Serial.printf("Voter Time: %u.%09u\r\n", t.vtime_sec, t.vtime_nsec);
      }
      Serial.printf("PPS Jitter: %u us\r\n", gpsMgr.getPpsJitter());
      // Re-print menu after a pause or keypress?
      // For now just back to prompt
      Serial.println("------------------\r");
      Serial.print("> ");
      Serial.print("> ");
      break;
    case 'r':
    case 'R': {
      Serial.print("\nEnter Simulated RSSI (0=Disable, 1-255): ");
      String val = readStringEcho(); // Use helper
      int r = val.toInt();
      if (r >= 0 && r <= 255) {
        g_simRSSI = (uint8_t)r;
        Serial.printf("\nSimulated RSSI set to %u\n", g_simRSSI);
      } else {
        Serial.println("\nInvalid Value (0-255).");
      }
      printMenu();
      break;
    }
    case '6': {
      Serial.println("\nSelect COS Mode:");
      Serial.println(" [0] Always On (No Squelch)");
      Serial.println(" [1] Hardware COS (GPIO Pin)");
      Serial.println(" [2] DSP Squelch (Noise Detection)");
      Serial.print("Enter mode: ");
      String val = readStringEcho();
      int mode = val.toInt();
      if (mode >= 0 && mode <= 2) {
        cfg.data.cosMode = mode;
        Serial.printf("\nCOS Mode set to %d\n", mode);
      } else {
        Serial.println("\nInvalid Mode (0-2).");
      }
      printMenu();
      break;
    }
    case '7': {
      Serial.print("\nEnter DSP Squelch Threshold (0-255): ");
      String val = readStringEcho();
      int thresh = val.toInt();
      if (thresh >= 0 && thresh <= 255) {
        cfg.data.dspSquelchThresh = thresh;
        Serial.printf("\nDSP Squelch Threshold set to %u\n", thresh);
      } else {
        Serial.println("\nInvalid Value (0-255).");
      }
      printMenu();
      break;
    }

    case '8': {
      int val = analogRead(RSSI_PIN);
      cfg.data.rssiMin = (uint16_t)val;
      Serial.printf("\nSet Min RSSI (0%%) to: %u\n", val);
      printMenu();
      break;
    }
    case '9': {
      int val = analogRead(RSSI_PIN);
      cfg.data.rssiMax = (uint16_t)val;
      Serial.printf("\nSet Max RSSI (100%%) to: %u\n", val);
      printMenu();
      break;
    }
    case 'n':
    case 'N': {
      g_noSignalMode = !g_noSignalMode;
      Serial.printf("\nNo Signal Mode: %s\n",
                    g_noSignalMode ? "ON (simulating squelched RX)" : "OFF");
      printMenu();
      break;
    }
    case 't':
    case 'T': {
      g_testToneMode = !g_testToneMode;
      resetAudioState(); // CRITICAL: Reset filters and buffers
      Serial.printf("\nTest Tone Mode: %s\n",
                    g_testToneMode ? "ON (1kHz sine wave)" : "OFF");
      printMenu();
      break;
    }
    case 'd':
    case 'D': {
      Serial.println("\n--- Signal Monitor (Press any key to exit) ---");
      while (!Serial.available()) {
        // Clear line / Return to start
        Serial.print("\r");

        // 1. RSSI
        uint8_t noise = dsp.getNoiseLevel();
        int analogRSSI = analogRead(RSSI_PIN);
        // Calculate "final" RSSI used by logic
        uint8_t finalRSSI = 0;
        if (cfg.data.useHwRSSI) {
          // Map with calibration
          long mapped =
              map(analogRSSI, cfg.data.rssiMin, cfg.data.rssiMax, 0, 255);
          if (mapped < 0)
            mapped = 0;
          if (mapped > 255)
            mapped = 255;
          finalRSSI = (uint8_t)mapped;
        } else {
          finalRSSI = (255 - noise);
        }

        // 2. COS
        bool hwCosActive = (digitalRead(COS_PIN) == LOW);
        bool dspCosActive = (noise < cfg.data.dspSquelchThresh);
        bool finalCos = (cfg.data.cosMode == COS_MODE_HARDWARE) ? hwCosActive
                        : (cfg.data.cosMode == COS_MODE_DSP)    ? dspCosActive
                                                                : true;

        // 3. GPS
        long ppsJitter = gpsMgr.getPpsJitter();
        (void)ppsJitter; // Usage in printf removed, silence warning
        bool gpsLocked = gpsMgr.isLocked();

        // Display
        Serial.printf("RSSI:%3u (ADC:%4d N:%3u) | COS:%s | GPS:%s | Min:%u "
                      "Max:%u   ",
                      finalRSSI, analogRSSI, noise, finalCos ? "ACT" : "idle",
                      gpsLocked ? "LCK" : "SRC", cfg.data.rssiMin,
                      cfg.data.rssiMax);

        delay(200);
      }
      // Consume the key that broke the loop
      if (Serial.available())
        Serial.read();
      printMenu();
      break;
    }
    }
  }
}

void setup() {
  // Force Recompile Check
  Serial.begin(115200);
  while (!Serial && millis() < 3000)
    ;
  Serial.println("[System] TeensyVoter Booting...");

  // Debug Pin for Oscilloscope
  pinMode(PIN_DEBUG_TX, OUTPUT);
  digitalWrite(PIN_DEBUG_TX, LOW);

  // COS Input Pin
  pinMode(COS_PIN, INPUT_PULLUP);

  // 0. Config (MUST BE FIRST)
  cfg.begin();

  // 1. Audio
  AudioMemory(50); // Need more memory for queues

  if (sgtl5000_1.enable()) {
    Serial.println("[Audio] SGTL5000 Audio Shield FOUND & Enabled");
  } else {
    Serial.println("[Audio] ERROR: SGTL5000 Audio Shield NOT DETECTED!");
    Serial.println("[Audio] Check I2C pins and power.");
  }

  sgtl5000_1.volume(g_headphoneVol);
  sgtl5000_1.inputSelect(
      (cfg.data.inputSource == 0)
          ? AUDIO_INPUT_LINEIN
          : AUDIO_INPUT_MIC); // for radio discriminator/audio output
  sgtl5000_1.lineInLevel(cfg.data.rxGain); // Line input level (0-15)

  // Start Recording
  mixer1.gain(0, 0.5); // Left Channel
  mixer1.gain(1, 0.5); // Right Channel
  recordQueue.begin();

  // Test Tone for Output (Right Channel Headphone)
  sine1.frequency(440);
  sine1.amplitude(0.5);
  // Serial.println("[DEBUG] FORCE ENABLED SINE WAVE 440Hz / 0.5");
  // sine1.frequency(440.0);

  // Initialize audio state
  resetAudioState();

  Serial.println("[Audio] SGTL5000 & Queue Initialized");

  Serial.printf("[Audio] Applied RX Gain: %u\n", cfg.data.rxGain);

  if (cfg.data.rxGain == 0)
    Serial.println("[WARNING] Gain is 0! Auto-Correcting to 12...");
  if (cfg.data.rxGain == 0) {
    cfg.data.rxGain = 12;
    sgtl5000_1.lineInLevel(12);
  }

  // 2. Hardware Serial
  WIFI_SERIAL.begin(115200);
  GPS_SERIAL.begin(9600);

  // 3. Network
  Serial.println("[System] Initializing Network Driver...");
  // netMgr.begin(&ethDriver, mac);
  // netMgr.begin(&spiDriver, mac);

  // Give ESP32 time to boot before sending credentials
  Serial.println("[System] Waiting for ESP32 Boot...");
  // delay(3000);
  // netMgr.begin(&spiDriver);
  // netMgr.begin(&ethDriver);

  // 7. Voter Client
  Serial.println("[Voter] Initializing Protocol Client...");
  // voter.begin(&netMgr);

  Serial.println("[System] Network Drivers DISABLED for Audio Test");

  // 4. GPS

  Serial.println("[GPS] Initializing GPS...");
  gpsMgr.begin(&GPS_SERIAL, PPS_PIN);

  // 4.1 Config (Moved to top)
  // cfg.begin();

  // Now we have config, set network target
  // netMgr.setTarget(cfg.getHostIP(), cfg.data.hostPort);

  // 5. Voter Client
  // Serial.println("[Voter] Initializing Protocol Client...");
  voter.begin(&netMgr, &gpsMgr, cfg.getHostIP(), cfg.data.hostPort,
              cfg.data.clientPwd, cfg.data.hostPwd);

  // 6. DSP
  dsp.begin();

  // 7. Web
  web.begin(&cfg, &gpsMgr, &voter);
  // Serial.println("[DEBUG] Minimal Mode: Only Audio + Serial Active");
}

void loop() {

  // 1. Core Updates
  handleSerialCLI();
  web.update();
  gpsMgr.update();
  /*
  netMgr.update();
  voter.update();
  */

  // 2. Audio Processing Loop
  // drain ALL available audio blocks to prevent latency buildup/overflow

  while (recordQueue.available() >= 1) { // Get audio block from queue
    int16_t *buff = recordQueue.readBuffer();
    if (!buff)
      continue; // Should not happen given check above, but safer than return

    /*
    // ... (DSP Logic Removed) ...
    recordQueue.freeBuffer();
    */

    // Generate test tone if enabled (1kHz sine wave)
    if (g_testToneMode) {
      // Use global phase for consistency across blocks & reset capability
      const float freq = 1000.0f;                       // 1kHz
      const float sampleRate = AUDIO_SAMPLE_RATE_EXACT; // 44117.6Hz
      const float amplitude =
          3000.0f; // Reduced to prevent clipping (was 20000)
      const float phaseIncrement = 2.0f * 3.14159265f * freq / sampleRate;

      for (int i = 0; i < AUDIO_BLOCK_SAMPLES; i++) {
        buff[i] = (int16_t)(amplitude * sinf(g_testTonePhase));
        g_testTonePhase += phaseIncrement;
        if (g_testTonePhase >= 2.0f * 3.14159265f)
          g_testTonePhase -= 2.0f * 3.14159265f;
      }
    }

    // 1. Run DSP (Filter & RSSI)
    bool enableFilters = !g_testToneMode;
    uint8_t baseRSSI = dsp.process(buff, enableFilters, enableFilters);

    if (cfg.data.useHwRSSI) {
      int analogVal = analogRead(RSSI_PIN);
      long mapped = map(analogVal, cfg.data.rssiMin, cfg.data.rssiMax, 0, 255);
      if (mapped < 0)
        mapped = 0;
      if (mapped > 255)
        mapped = 255;
      baseRSSI = (uint8_t)mapped;

      static unsigned long lastDebug = 0;
      if (millis() - lastDebug > 1000) {
        lastDebug = millis();
        Serial.printf("[DEBUG] ADC:%d Min:%u Max:%u -> Map:%ld\n", analogVal,
                      cfg.data.rssiMin, cfg.data.rssiMax, mapped);
      }
    }
    if (g_simRSSI > 0)
      baseRSSI = g_simRSSI;

    // Apply COS/Squelch logic
    uint8_t finalRSSI = baseRSSI;
    switch (cfg.data.cosMode) {
    case COS_MODE_HARDWARE:
      // Active LOW: LOW = Signal, HIGH = No Signal
      // If HIGH (No Signal), force RSSI to 0
      if (digitalRead(COS_PIN) == HIGH)
        finalRSSI = 0;
      break;
    case COS_MODE_DSP:
      if (dsp.getNoiseLevel() >= cfg.data.dspSquelchThresh)
        finalRSSI = 0;
      break;
    default:
      break;
    }

    // 2. Downsample 44.1k -> 8k using Simple Averaging
    // Unconditionally stable "Boxcar" filter to eliminate ringing/instability.
    // Use EXACT sample rate to prevent drift: 44117.647 / 8000 = 5.5147
    const float DECIMATION_RATIO = AUDIO_SAMPLE_RATE_EXACT / 8000.0f;
    // Global g_avgSum and g_avgCount used here

    int outputCount = 0;
    for (int i = 0; i < AUDIO_BLOCK_SAMPLES && (accHead + outputCount) < 512;
         i++) {
      g_avgSum += (float)buff[i];
      g_avgCount++;

      samplePosition += 1.0f;

      if (samplePosition >= DECIMATION_RATIO) {
        // Average and Output
        float avg = g_avgSum / (float)g_avgCount;

        if (avg > 32760.0f)
          avg = 32760.0f;
        if (avg < -32760.0f)
          avg = -32760.0f;

        accumulationBuf[accHead + outputCount] = (int16_t)avg;
        outputCount++;

        // Reset accumulation for next sample
        g_avgSum = 0.0f;
        g_avgCount = 0;
        samplePosition -= DECIMATION_RATIO;
      }
    }

    accHead += outputCount;

    recordQueue.freeBuffer();

    // 3. Check if we have enough for a Frame (160 samples)
    if (accHead >= 160) {
      uint8_t ulawFrame[160];
      dsp.encodeULaw(accumulationBuf, ulawFrame, 160);

      // Only send if we are NOT in "No Signal Mode"
      bool shouldSend = true;
      if (g_noSignalMode)
        shouldSend = false;

      if (shouldSend) {
        // Use the proper client method which handles sequence, timestamp, and
        // sending
        // voter.processAudioFrame(ulawFrame, finalRSSI);
        // Serial.println("[Test] Generated Audio Frame (Not Sent)");
      }

      // Move remaining samples in buffer to front
      int remaining = accHead - 160;
      if (remaining > 0) {
        memmove(accumulationBuf, &accumulationBuf[160],
                remaining * sizeof(int16_t));
        accHead = remaining;
      } else {
        accHead = 0;
      }
    }
  }
}
